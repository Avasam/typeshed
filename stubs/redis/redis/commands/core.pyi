import builtins
from _typeshed import Incomplete
from collections.abc import AsyncIterator, Awaitable, Callable, Iterable, Iterator, Mapping, Sequence
from datetime import datetime, timedelta
from typing import Any, Generic, TypeVar, overload
from typing_extensions import Literal, TypeAlias

from ..asyncio.client import Redis as AsyncRedis
from ..client import _CommandOptions, _Value
from ..typing import BitfieldOffsetT, ChannelT, CommandsProtocol, EncodableT, KeysT, KeyT, PatternT, ScriptTextT, StreamIdT

_ScoreCastFuncReturn = TypeVar("_ScoreCastFuncReturn")
_StrType = TypeVar("_StrType", bound=str | bytes)

ResponseT: TypeAlias = Awaitable[Incomplete] | Incomplete

class ACLCommands(CommandsProtocol, Generic[_StrType]):
    def acl_cat(self, category: str | None = None, **kwargs: _CommandOptions) -> list[str]: ...
    def acl_dryrun(self, username, *args, **kwargs): ...
    def acl_deluser(self, *username: str, **kwargs: _CommandOptions) -> int: ...
    def acl_genpass(self, bits: int | None = None, **kwargs: _CommandOptions) -> str: ...
    def acl_getuser(self, username: str, **kwargs: _CommandOptions) -> Any | None: ...
    def acl_help(self, **kwargs: _CommandOptions): ...
    def acl_list(self, **kwargs: _CommandOptions) -> list[str]: ...
    def acl_log(self, count: int | None = None, **kwargs: _CommandOptions): ...
    def acl_log_reset(self, **kwargs: _CommandOptions): ...
    def acl_load(self, **kwargs: _CommandOptions) -> bool: ...
    def acl_save(self, **kwargs: _CommandOptions): ...
    def acl_setuser(
        self,
        username: str,
        enabled: bool = False,
        nopass: bool = False,
        passwords: Sequence[str] | None = None,
        hashed_passwords: Sequence[str] | None = None,
        categories: Sequence[str] | None = None,
        commands: Sequence[str] | None = None,
        keys: Sequence[str] | None = None,
        channels: Iterable[ChannelT] | None = None,
        selectors: Iterable[tuple[str, KeyT]] | None = None,
        reset: bool = False,
        reset_keys: bool = False,
        reset_channels: bool = False,
        reset_passwords: bool = False,
        **kwargs: _CommandOptions,
    ) -> bool: ...
    def acl_users(self, **kwargs: _CommandOptions) -> list[str]: ...
    def acl_whoami(self, **kwargs: _CommandOptions) -> str: ...

AsyncACLCommands = ACLCommands

class ManagementCommands(CommandsProtocol):
    def auth(self, password: str, username: str | None = ..., **kwargs): ...
    def bgrewriteaof(self, **kwargs: _CommandOptions): ...
    def bgsave(self, schedule: bool = True, **kwargs: _CommandOptions): ...
    def role(self): ...
    def client_kill(self, address: str, **kwargs: _CommandOptions) -> bool: ...
    def client_kill_filter(
        self,
        _id: Incomplete | None = None,
        _type: Incomplete | None = None,
        addr: Incomplete | None = None,
        skipme: Incomplete | None = None,
        laddr: Incomplete | None = None,
        user: Incomplete | None = None,
        **kwargs: _CommandOptions,
    ): ...
    def client_info(self, **kwargs: _CommandOptions): ...
    def client_list(
        self, _type: str | None = None, client_id: list[str] = [], **kwargs: _CommandOptions
    ) -> list[dict[str, str]]: ...
    def client_getname(self, **kwargs: _CommandOptions) -> str | None: ...
    def client_getredir(self, **kwargs: _CommandOptions): ...
    def client_reply(self, reply, **kwargs: _CommandOptions): ...
    def client_id(self, **kwargs: _CommandOptions) -> int: ...
    def client_tracking_on(
        self,
        clientid: Incomplete | None = None,
        prefix=[],
        bcast: bool = False,
        optin: bool = False,
        optout: bool = False,
        noloop: bool = False,
    ): ...
    def client_tracking_off(
        self,
        clientid: Incomplete | None = None,
        prefix=[],
        bcast: bool = False,
        optin: bool = False,
        optout: bool = False,
        noloop: bool = False,
    ): ...
    def client_tracking(
        self,
        on: bool = True,
        clientid: Incomplete | None = None,
        prefix=[],
        bcast: bool = False,
        optin: bool = False,
        optout: bool = False,
        noloop: bool = False,
        **kwargs: _CommandOptions,
    ): ...
    def client_trackinginfo(self, **kwargs: _CommandOptions): ...
    def client_setname(self, name: str, **kwargs: _CommandOptions) -> bool: ...
    def client_setinfo(self, attr: str, value: str, **kwargs) -> ResponseT: ...
    def client_unblock(self, client_id, error: bool = False, **kwargs: _CommandOptions): ...
    def client_pause(self, timeout, all: bool = True, **kwargs: _CommandOptions): ...
    def client_unpause(self, **kwargs: _CommandOptions): ...
    def client_no_evict(self, mode: str): ...
    def client_no_touch(self, mode: str): ...
    def command(self, **kwargs: _CommandOptions): ...
    def command_info(self, **kwargs: _CommandOptions): ...
    def command_count(self, **kwargs: _CommandOptions): ...
    def command_list(self, module: str | None = ..., category: str | None = ..., pattern: str | None = ...) -> ResponseT: ...
    def command_getkeysandflags(self, *args: list[str]) -> list[str | list[str]]: ...
    def command_docs(self, *args) -> None: ...
    def config_get(self, pattern: PatternT = "*", *args: PatternT, **kwargs: _CommandOptions): ...
    def config_set(self, name: KeyT, value: EncodableT, *args: KeyT | EncodableT, **kwargs: _CommandOptions): ...
    def config_resetstat(self, **kwargs: _CommandOptions): ...
    def config_rewrite(self, **kwargs: _CommandOptions): ...
    def dbsize(self, **kwargs: _CommandOptions) -> int: ...
    def debug_object(self, key, **kwargs: _CommandOptions): ...
    def debug_segfault(self, **kwargs: _CommandOptions): ...
    def echo(self, value: _Value, **kwargs: _CommandOptions) -> bytes: ...
    def flushall(self, asynchronous: bool = False, **kwargs: _CommandOptions) -> bool: ...
    def flushdb(self, asynchronous: bool = False, **kwargs: _CommandOptions) -> bool: ...
    def sync(self): ...
    def psync(self, replicationid, offset): ...
    def swapdb(self, first, second, **kwargs: _CommandOptions): ...
    def select(self, index, **kwargs: _CommandOptions): ...
    def info(self, section: KeyT | None = None, *args: KeyT, **kwargs: _CommandOptions) -> Mapping[str, Any]: ...
    def lastsave(self, **kwargs: _CommandOptions): ...
    def latency_doctor(self) -> None: ...
    def latency_graph(self) -> None: ...
    def lolwut(self, *version_numbers: _Value, **kwargs: _CommandOptions) -> bytes: ...
    def reset(self) -> None: ...
    def migrate(
        self,
        host,
        port,
        keys,
        destination_db,
        timeout,
        copy: bool = False,
        replace: bool = False,
        auth: Incomplete | None = None,
        **kwargs: _CommandOptions,
    ): ...
    def object(self, infotype, key, **kwargs: _CommandOptions): ...
    def memory_doctor(self, **kwargs: _CommandOptions): ...
    def memory_help(self, **kwargs: _CommandOptions): ...
    def memory_stats(self, **kwargs: _CommandOptions) -> dict[str, Any]: ...
    def memory_malloc_stats(self, **kwargs: _CommandOptions): ...
    def memory_usage(self, key, samples: Incomplete | None = None, **kwargs: _CommandOptions): ...
    def memory_purge(self, **kwargs: _CommandOptions): ...
    def latency_histogram(self, *args) -> None: ...
    def latency_history(self, event: str) -> ResponseT: ...
    def latency_latest(self) -> ResponseT: ...
    def latency_reset(self, *events: str) -> ResponseT: ...
    def ping(self, **kwargs: _CommandOptions) -> bool: ...
    def quit(self, **kwargs: _CommandOptions): ...
    def replicaof(self, *args, **kwargs: _CommandOptions): ...
    def save(self, **kwargs: _CommandOptions) -> bool: ...
    def shutdown(
        self,
        save: bool = False,
        nosave: bool = False,
        now: bool = False,
        force: bool = False,
        abort: bool = False,
        **kwargs: _CommandOptions,
    ) -> None: ...
    def slaveof(self, host: Incomplete | None = None, port: Incomplete | None = None, **kwargs: _CommandOptions): ...
    def slowlog_get(self, num: Incomplete | None = None, **kwargs: _CommandOptions): ...
    def slowlog_len(self, **kwargs: _CommandOptions): ...
    def slowlog_reset(self, **kwargs: _CommandOptions): ...
    def time(self, **kwargs: _CommandOptions): ...
    def wait(self, num_replicas, timeout, **kwargs: _CommandOptions): ...
    def waitaof(self, num_local: int, num_replicas: int, timeout: int, **kwargs) -> ResponseT: ...
    def hello(self) -> None: ...
    def failover(self) -> None: ...

class AsyncManagementCommands(ManagementCommands):
    async def command_info(self, **kwargs: _CommandOptions): ...
    async def debug_segfault(self, **kwargs: _CommandOptions): ...
    async def memory_doctor(self, **kwargs: _CommandOptions): ...
    async def memory_help(self, **kwargs: _CommandOptions): ...
    async def shutdown(  # type: ignore[override]  # Incompatible return type
        self,
        save: bool = False,
        nosave: bool = False,
        now: bool = False,
        force: bool = False,
        abort: bool = False,
        **kwargs: _CommandOptions,
    ) -> None: ...

class BitFieldOperation:
    client: Incomplete
    key: Incomplete
    operations: Incomplete
    def __init__(self, client, key, default_overflow: Incomplete | None = None): ...
    def reset(self) -> None: ...
    def overflow(self, overflow): ...
    def incrby(self, fmt, offset, increment, overflow: Incomplete | None = None): ...
    def get(self, fmt, offset): ...
    def set(self, fmt, offset, value): ...
    @property
    def command(self): ...
    def execute(self): ...

class BasicKeyCommands(CommandsProtocol, Generic[_StrType]):
    def append(self, key, value): ...
    def bitcount(self, key: KeyT, start: int | None = None, end: int | None = None, mode: str | None = None) -> int: ...
    def bitfield(self, key, default_overflow: Incomplete | None = None): ...
    def bitfield_ro(
        self, key: KeyT, encoding: str, offset: BitfieldOffsetT, items: list[Incomplete] | None = ...
    ) -> ResponseT: ...
    def bitop(self, operation, dest, *keys): ...
    def bitpos(self, key: KeyT, bit: int, start: int | None = None, end: int | None = None, mode: str | None = None): ...
    def copy(self, source, destination, destination_db: Incomplete | None = None, replace: bool = False): ...
    def decrby(self, name, amount: int = 1) -> int: ...
    decr = decrby
    def delete(self, *names: KeyT) -> int: ...
    def __delitem__(self, name: KeyT) -> None: ...
    def dump(self, name: KeyT) -> _StrType | None: ...
    def exists(self, *names: KeyT) -> int: ...
    __contains__ = exists
    def expire(
        self, name: KeyT, time: int | timedelta, nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False
    ) -> bool: ...
    def expireat(self, name, when, nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False): ...
    def expiretime(self, key: str) -> int: ...
    def get(self, name: KeyT) -> _StrType | None: ...
    def getdel(self, name: KeyT) -> _StrType | None: ...
    def getex(
        self,
        name,
        ex: Incomplete | None = None,
        px: Incomplete | None = None,
        exat: Incomplete | None = None,
        pxat: Incomplete | None = None,
        persist: bool = False,
    ): ...
    def __getitem__(self, name: str): ...
    def getbit(self, name: KeyT, offset: int) -> int: ...
    def getrange(self, key, start, end): ...
    def getset(self, name, value) -> _StrType | None: ...
    def incrby(self, name: KeyT, amount: int = 1) -> int: ...
    incr = incrby
    def incrbyfloat(self, name: KeyT, amount: float = 1.0) -> float: ...
    def keys(self, pattern: KeyT = "*", **kwargs: _CommandOptions) -> list[_StrType]: ...
    def lmove(
        self,
        first_list: KeyT,
        second_list: KeyT,
        src: Literal["LEFT", "RIGHT"] = "LEFT",
        dest: Literal["LEFT", "RIGHT"] = "RIGHT",
    ) -> _Value: ...
    def blmove(
        self,
        first_list: KeyT,
        second_list: KeyT,
        timeout: float,
        src: Literal["LEFT", "RIGHT"] = "LEFT",
        dest: Literal["LEFT", "RIGHT"] = "RIGHT",
    ) -> _Value | None: ...
    def mget(self, keys: KeyT | Iterable[KeyT], *args: KeyT) -> list[_StrType | None]: ...
    def mset(self, mapping: Mapping[KeyT, _Value]) -> Literal[True]: ...
    def msetnx(self, mapping: Mapping[KeyT, _Value]) -> bool: ...
    def move(self, name: KeyT, db: int) -> bool: ...
    def persist(self, name: KeyT) -> bool: ...
    def pexpire(
        self, name: KeyT, time: int | timedelta, nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False
    ) -> Literal[1, 0]: ...
    def pexpireat(
        self, name: KeyT, when: int | datetime, nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False
    ) -> Literal[1, 0]: ...
    def pexpiretime(self, key: str) -> int: ...
    def psetex(self, name, time_ms, value): ...
    def pttl(self, name: KeyT) -> int: ...
    def hrandfield(self, key, count: Incomplete | None = None, withvalues: bool = False): ...
    def randomkey(self, **kwargs: _CommandOptions): ...
    def rename(self, src, dst): ...
    def renamenx(self, src, dst): ...
    def restore(
        self,
        name,
        ttl,
        value,
        replace: bool = False,
        absttl: bool = False,
        idletime: Incomplete | None = None,
        frequency: Incomplete | None = None,
    ): ...
    def set(
        self,
        name: KeyT,
        value: _Value,
        ex: None | float | timedelta = None,
        px: None | float | timedelta = None,
        nx: bool = False,
        xx: bool = False,
        keepttl: bool = False,
        get: bool = False,
        exat: Incomplete | None = None,
        pxat: Incomplete | None = None,
    ) -> bool | None: ...
    def __setitem__(self, name, value) -> None: ...
    def setbit(self, name: KeyT, offset: int, value: int) -> int: ...
    def setex(self, name: KeyT, time: int | timedelta, value: _Value) -> bool: ...
    def setnx(self, name: KeyT, value: _Value) -> bool: ...
    def setrange(self, name, offset, value): ...
    def stralgo(
        self,
        algo,
        value1,
        value2,
        specific_argument: str = "strings",
        len: bool = False,
        idx: bool = False,
        minmatchlen: Incomplete | None = None,
        withmatchlen: bool = False,
        **kwargs: _CommandOptions,
    ): ...
    def strlen(self, name): ...
    def substr(self, name, start, end: int = -1): ...
    def touch(self, *args): ...
    def ttl(self, name: KeyT) -> int: ...
    def type(self, name): ...
    def watch(self, *names): ...
    def unwatch(self): ...
    def unlink(self, *names: KeyT) -> int: ...
    def lcs(
        self,
        key1: str,
        key2: str,
        len: bool | None = ...,
        idx: bool | None = ...,
        minmatchlen: int | None = ...,
        withmatchlen: bool | None = ...,
    ) -> str | int | list[Incomplete]: ...

class AsyncBasicKeyCommands(BasicKeyCommands[_StrType], Generic[_StrType]):
    def __delitem__(self, name: KeyT): ...
    def __contains__(self, name: KeyT): ...  # type: ignore[override]  # Different params
    def __getitem__(self, name: KeyT): ...
    def __setitem__(self, name: KeyT, value: EncodableT): ...
    async def watch(self, *names: KeyT) -> None: ...
    async def unwatch(self) -> None: ...

class ListCommands(CommandsProtocol, Generic[_StrType]):
    @overload
    def blpop(self, keys: _Value | Iterable[_Value], timeout: Literal[0] | None = 0) -> tuple[_StrType, _StrType]: ...
    @overload
    def blpop(self, keys: _Value | Iterable[_Value], timeout: float) -> tuple[_StrType, _StrType] | None: ...
    @overload
    def brpop(self, keys: _Value | Iterable[_Value], timeout: Literal[0] | None = 0) -> tuple[_StrType, _StrType]: ...
    @overload
    def brpop(self, keys: _Value | Iterable[_Value], timeout: float) -> tuple[_StrType, _StrType] | None: ...
    def brpoplpush(self, src, dst, timeout: int | None = 0): ...
    def blmpop(
        self, timeout: float, numkeys: int, *args: list[str], direction: str, count: int | None = ...
    ) -> list[Incomplete] | None: ...
    def lmpop(
        self, num_keys: int, *args: list[str], direction: str, count: int | None = ...
    ) -> Awaitable[list[Incomplete]] | list[Incomplete]: ...
    def lindex(self, name: KeyT, index: int) -> _StrType | None: ...
    def linsert(
        self, name: KeyT, where: Literal["BEFORE", "AFTER", "before", "after"], refvalue: _Value, value: _Value
    ) -> int: ...
    def llen(self, name: KeyT) -> int: ...
    def lpop(self, name, count: int | None = None): ...
    def lpush(self, name: _Value, *values: _Value) -> int: ...
    def lpushx(self, name, value): ...
    def lrange(self, name: KeyT, start: int, end: int) -> list[_StrType]: ...
    def lrem(self, name: KeyT, count: int, value: _Value) -> int: ...
    def lset(self, name: KeyT, index: int, value: _Value) -> bool: ...
    def ltrim(self, name: KeyT, start: int, end: int) -> bool: ...
    def rpop(self, name, count: int | None = None): ...
    def rpoplpush(self, src, dst): ...
    def rpush(self, name: _Value, *values: _Value) -> int: ...
    def rpushx(self, name, value): ...
    def lpos(
        self, name, value, rank: Incomplete | None = None, count: Incomplete | None = None, maxlen: Incomplete | None = None
    ): ...
    @overload
    def sort(
        self,
        name: KeyT,
        start: int | None = None,
        num: int | None = None,
        by: KeyT | None = None,
        get: KeyT | Sequence[KeyT] | None = None,
        desc: bool = False,
        alpha: bool = False,
        store: None = None,
        groups: bool = False,
    ) -> list[_StrType]: ...
    @overload
    def sort(
        self,
        name: KeyT,
        start: int | None = None,
        num: int | None = None,
        by: KeyT | None = None,
        get: KeyT | Sequence[KeyT] | None = None,
        desc: bool = False,
        alpha: bool = False,
        *,
        store: KeyT,
        groups: bool = False,
    ) -> int: ...
    @overload
    def sort(
        self,
        name: KeyT,
        start: int | None,
        num: int | None,
        by: KeyT | None,
        get: KeyT | Sequence[KeyT] | None,
        desc: bool,
        alpha: bool,
        store: KeyT,
        groups: bool = False,
    ) -> int: ...
    def sort_ro(
        self,
        key: str,
        start: int | None = ...,
        num: int | None = ...,
        by: str | None = ...,
        get: list[str] | None = ...,
        desc: bool = ...,
        alpha: bool = ...,
    ) -> list[Incomplete]: ...

AsyncListCommands = ListCommands

class ScanCommands(CommandsProtocol, Generic[_StrType]):
    def scan(
        self,
        cursor: int = 0,
        match: KeyT | None = None,
        count: int | None = None,
        _type: str | None = None,
        **kwargs: _CommandOptions,
    ) -> tuple[int, list[_StrType]]: ...
    def scan_iter(
        self, match: KeyT | None = None, count: int | None = None, _type: str | None = None, **kwargs: _CommandOptions
    ) -> Iterator[_StrType]: ...
    def sscan(
        self, name: KeyT, cursor: int = 0, match: KeyT | None = None, count: int | None = None
    ) -> tuple[int, list[_StrType]]: ...
    def sscan_iter(self, name: KeyT, match: KeyT | None = None, count: int | None = None) -> Iterator[_StrType]: ...
    def hscan(
        self, name: KeyT, cursor: int = 0, match: KeyT | None = None, count: int | None = None
    ) -> tuple[int, dict[_StrType, _StrType]]: ...
    def hscan_iter(
        self, name: KeyT, match: KeyT | None = None, count: int | None = None
    ) -> Iterator[tuple[_StrType, _StrType]]: ...
    @overload
    def zscan(
        self, name: KeyT, cursor: int = 0, match: KeyT | None = None, count: int | None = None
    ) -> tuple[int, list[tuple[_StrType, float]]]: ...
    @overload
    def zscan(
        self,
        name: KeyT,
        cursor: int = 0,
        match: KeyT | None = None,
        count: int | None = None,
        *,
        score_cast_func: Callable[[_StrType], _ScoreCastFuncReturn],
    ) -> tuple[int, list[tuple[_StrType, _ScoreCastFuncReturn]]]: ...
    @overload
    def zscan(
        self,
        name: KeyT,
        cursor: int,
        match: KeyT | None,
        count: int | None,
        score_cast_func: Callable[[_StrType], _ScoreCastFuncReturn],
    ) -> tuple[int, list[tuple[_StrType, _ScoreCastFuncReturn]]]: ...
    @overload
    def zscan_iter(self, name: KeyT, match: KeyT | None = None, count: int | None = None) -> Iterator[tuple[_StrType, float]]: ...
    @overload
    def zscan_iter(
        self,
        name: KeyT,
        match: KeyT | None = None,
        count: int | None = None,
        *,
        score_cast_func: Callable[[_StrType], _ScoreCastFuncReturn],
    ) -> Iterator[tuple[_StrType, _ScoreCastFuncReturn]]: ...
    @overload
    def zscan_iter(
        self, name: KeyT, match: KeyT | None, count: int | None, score_cast_func: Callable[[_StrType], _ScoreCastFuncReturn]
    ) -> Iterator[tuple[_StrType, _ScoreCastFuncReturn]]: ...

class AsyncScanCommands(ScanCommands[_StrType], Generic[_StrType]):
    async def scan(  # type: ignore[override]  # Incompatible return type
        self,
        cursor: int = 0,
        match: KeyT | None = None,
        count: int | None = None,
        _type: str | None = None,
        **kwargs: _CommandOptions,
    ) -> tuple[int, list[_StrType]]: ...
    def scan_iter(  # type: ignore[override]  # Incompatible return type
        self, match: KeyT | None = None, count: int | None = None, _type: str | None = None, **kwargs: _CommandOptions
    ) -> AsyncIterator[_StrType]: ...
    async def sscan(  # type: ignore[override]  # Incompatible return type
        self, name: KeyT, cursor: int = 0, match: KeyT | None = None, count: int | None = None
    ) -> tuple[int, list[_StrType]]: ...
    def sscan_iter(  # type: ignore[override]  # Incompatible return type
        self, name: KeyT, match: KeyT | None = None, count: int | None = None
    ) -> AsyncIterator[_StrType]: ...
    async def hscan(  # type: ignore[override]  # Incompatible return type
        self, name: KeyT, cursor: int = 0, match: KeyT | None = None, count: int | None = None
    ) -> tuple[int, dict[_StrType, _StrType]]: ...
    def hscan_iter(  # type: ignore[override]  # Incompatible return type
        self, name: KeyT, match: KeyT | None = None, count: int | None = None
    ) -> AsyncIterator[tuple[_StrType, _StrType]]: ...
    @overload  # type: ignore[override]  # Different signature from supertype
    async def zscan(
        self, name: KeyT, cursor: int = 0, match: KeyT | None = None, count: int | None = None
    ) -> tuple[int, list[tuple[_StrType, float]]]: ...
    @overload
    async def zscan(
        self,
        name: KeyT,
        cursor: int = 0,
        match: KeyT | None = None,
        count: int | None = None,
        *,
        score_cast_func: Callable[[_StrType], _ScoreCastFuncReturn],
    ) -> tuple[int, list[tuple[_StrType, _ScoreCastFuncReturn]]]: ...
    @overload
    async def zscan(
        self,
        name: KeyT,
        cursor: int,
        match: KeyT | None,
        count: int | None,
        score_cast_func: Callable[[_StrType], _ScoreCastFuncReturn],
    ) -> tuple[int, list[tuple[_StrType, _ScoreCastFuncReturn]]]: ...
    @overload  # type: ignore[override]  # Different signature from supertype
    def zscan_iter(
        self, name: KeyT, match: KeyT | None = None, count: int | None = None
    ) -> AsyncIterator[tuple[_StrType, float]]: ...
    @overload
    def zscan_iter(
        self,
        name: KeyT,
        match: KeyT | None = None,
        count: int | None = None,
        *,
        score_cast_func: Callable[[_StrType], _ScoreCastFuncReturn],
    ) -> AsyncIterator[tuple[_StrType, _ScoreCastFuncReturn]]: ...
    @overload
    def zscan_iter(
        self, name: KeyT, match: KeyT | None, count: int | None, score_cast_func: Callable[[_StrType], _ScoreCastFuncReturn]
    ) -> AsyncIterator[tuple[_StrType, _ScoreCastFuncReturn]]: ...

class SetCommands(Generic[_StrType]):
    def sadd(self, name: KeyT, *values: _Value) -> int: ...
    def scard(self, name: KeyT) -> int: ...
    def sdiff(self, keys: KeyT | Iterable[KeyT], *args: KeyT) -> builtins.set[_Value]: ...
    def sdiffstore(self, dest: KeyT, keys: KeyT | Iterable[KeyT], *args: KeyT) -> int: ...
    def sinter(self, keys: KeyT | Iterable[KeyT], *args: KeyT) -> builtins.set[_Value]: ...
    def sinterstore(self, dest: KeyT, keys: KeyT | Iterable[KeyT], *args: KeyT) -> int: ...
    def sismember(self, name: KeyT, value: _Value) -> bool: ...
    def smembers(self, name: KeyT) -> builtins.set[_StrType]: ...
    def smismember(self, name, values, *args): ...
    def smove(self, src: KeyT, dst: KeyT, value: _Value) -> bool: ...
    @overload
    def spop(self, name: KeyT, count: None = None) -> _Value | None: ...
    @overload
    def spop(self, name: KeyT, count: int) -> list[_Value]: ...
    @overload
    def srandmember(self, name: KeyT, number: None = None) -> _Value | None: ...
    @overload
    def srandmember(self, name: KeyT, number: int) -> list[_Value]: ...
    def srem(self, name: KeyT, *values: _Value) -> int: ...
    def sunion(self, keys: KeyT | Iterable[KeyT], *args: KeyT) -> builtins.set[_Value]: ...
    def sunionstore(self, dest: KeyT, keys: KeyT | Iterable[KeyT], *args: KeyT) -> int: ...

AsyncSetCommands = SetCommands

class StreamCommands(CommandsProtocol):
    def xack(self, name, groupname, *ids): ...
    def xadd(
        self,
        name: KeyT,
        fields: Mapping[bytes | memoryview | str | float, bytes | memoryview | str | float],
        id: str | int | bytes | memoryview = "*",
        maxlen=None,
        approximate: bool = True,
        nomkstream: bool = False,
        minid: Incomplete | None = None,
        limit: Incomplete | None = None,
    ): ...
    def xautoclaim(
        self,
        name,
        groupname,
        consumername,
        min_idle_time,
        start_id: StreamIdT = "0-0",
        count: Incomplete | None = None,
        justid: bool = False,
    ): ...
    def xclaim(
        self,
        name,
        groupname,
        consumername,
        min_idle_time,
        message_ids,
        idle=None,
        time=None,
        retrycount=None,
        force=False,
        justid=False,
    ): ...
    def xdel(self, name: KeyT, *ids: str | int | bytes | memoryview): ...
    def xgroup_create(self, name, groupname, id: str = "$", mkstream: bool = False, entries_read: int | None = None): ...
    def xgroup_delconsumer(self, name, groupname, consumername): ...
    def xgroup_destroy(self, name, groupname): ...
    def xgroup_createconsumer(self, name, groupname, consumername): ...
    def xgroup_setid(self, name, groupname, id, entries_read: int | None = None): ...
    def xinfo_consumers(self, name, groupname): ...
    def xinfo_groups(self, name): ...
    def xinfo_stream(self, name, full: bool = False): ...
    def xlen(self, name: KeyT) -> int: ...
    def xpending(self, name, groupname): ...
    def xpending_range(
        self, name: KeyT, groupname, min, max, count: int, consumername: Incomplete | None = None, idle: int | None = None
    ): ...
    def xrange(self, name, min: str = "-", max: str = "+", count: Incomplete | None = None): ...
    def xread(self, streams, count: Incomplete | None = None, block: Incomplete | None = None): ...
    def xreadgroup(
        self,
        groupname,
        consumername,
        streams,
        count: Incomplete | None = None,
        block: Incomplete | None = None,
        noack: bool = False,
    ): ...
    def xrevrange(self, name, max: str = "+", min: str = "-", count: Incomplete | None = None): ...
    def xtrim(
        self, name, maxlen: int | None = None, approximate: bool = True, minid: Incomplete | None = None, limit: int | None = None
    ): ...

AsyncStreamCommands = StreamCommands

class SortedSetCommands(CommandsProtocol, Generic[_StrType]):
    def zadd(
        self,
        name: KeyT,
        mapping: Mapping[KeyT, _Value],
        nx: bool = False,
        xx: bool = False,
        ch: bool = False,
        incr: bool = False,
        gt: Incomplete | None = False,
        lt: Incomplete | None = False,
    ) -> int: ...
    def zcard(self, name: KeyT) -> int: ...
    def zcount(self, name: KeyT, min: _Value, max: _Value) -> int: ...
    def zdiff(self, keys, withscores: bool = False): ...
    def zdiffstore(self, dest, keys): ...
    def zincrby(self, name: KeyT, amount: float, value: _Value) -> float: ...
    def zinter(self, keys, aggregate: Incomplete | None = None, withscores: bool = False): ...
    def zinterstore(self, dest: KeyT, keys: Iterable[KeyT], aggregate: Literal["SUM", "MIN", "MAX"] | None = None) -> int: ...
    def zintercard(self, numkeys: int, keys: list[str], limit: int = ...) -> Awaitable[int] | int: ...
    def zlexcount(self, name: KeyT, min: _Value, max: _Value) -> int: ...
    def zpopmax(self, name: KeyT, count: int | None = None) -> list[tuple[_StrType, float]]: ...
    def zpopmin(self, name: KeyT, count: int | None = None) -> list[tuple[_StrType, float]]: ...
    def zrandmember(self, key, count: Incomplete | None = None, withscores: bool = False): ...
    @overload
    def bzpopmax(self, keys: KeyT | Iterable[KeyT], timeout: Literal[0] = 0) -> tuple[_StrType, _StrType, float]: ...
    @overload
    def bzpopmax(self, keys: KeyT | Iterable[KeyT], timeout: float) -> tuple[_StrType, _StrType, float] | None: ...
    @overload
    def bzpopmin(self, keys: KeyT | Iterable[KeyT], timeout: Literal[0] = 0) -> tuple[_StrType, _StrType, float]: ...
    @overload
    def bzpopmin(self, keys: KeyT | Iterable[KeyT], timeout: float) -> tuple[_StrType, _StrType, float] | None: ...
    @overload
    def zrange(
        self,
        name: KeyT,
        start: int,
        end: int,
        desc: bool,
        withscores: Literal[True],
        score_cast_func: Callable[[_StrType], _ScoreCastFuncReturn],
        byscore: bool = False,
        bylex: bool = False,
        offset: int | None = None,
        num: int | None = None,
    ) -> list[tuple[_StrType, _ScoreCastFuncReturn]]: ...
    @overload
    def zrange(
        self,
        name: KeyT,
        start: int,
        end: int,
        desc: bool,
        withscores: Literal[True],
        score_cast_func: Callable[[_StrType], float] = ...,
        byscore: bool = False,
        bylex: bool = False,
        offset: int | None = None,
        num: int | None = None,
    ) -> list[tuple[_StrType, float]]: ...
    @overload
    def zrange(
        self,
        name: KeyT,
        start: int,
        end: int,
        *,
        withscores: Literal[True],
        score_cast_func: Callable[[_StrType], _ScoreCastFuncReturn],
        byscore: bool = False,
        bylex: bool = False,
        offset: int | None = None,
        num: int | None = None,
    ) -> list[tuple[_StrType, _ScoreCastFuncReturn]]: ...
    @overload
    def zrange(
        self,
        name: KeyT,
        start: int,
        end: int,
        *,
        withscores: Literal[True],
        score_cast_func: Callable[[_StrType], float] = ...,
        byscore: bool = False,
        bylex: bool = False,
        offset: int | None = None,
        num: int | None = None,
    ) -> list[tuple[_StrType, float]]: ...
    @overload
    def zrange(
        self,
        name: KeyT,
        start: int,
        end: int,
        desc: bool = False,
        withscores: bool = False,
        score_cast_func: Callable[[_StrType], Any] = ...,
        byscore: bool = False,
        bylex: bool = False,
        offset: int | None = None,
        num: int | None = None,
    ) -> list[_StrType]: ...
    @overload
    def zrevrange(
        self,
        name: KeyT,
        start: int,
        end: int,
        withscores: Literal[True],
        score_cast_func: Callable[[_StrType], _ScoreCastFuncReturn],
    ) -> list[tuple[_StrType, _ScoreCastFuncReturn]]: ...
    @overload
    def zrevrange(self, name: KeyT, start: int, end: int, withscores: Literal[True]) -> list[tuple[_StrType, float]]: ...
    @overload
    def zrevrange(
        self, name: KeyT, start: int, end: int, withscores: bool = False, score_cast_func: Callable[[Any], Any] = ...
    ) -> list[_StrType]: ...
    def zrangestore(
        self,
        dest,
        name,
        start,
        end,
        byscore: bool = False,
        bylex: bool = False,
        desc: bool = False,
        offset: Incomplete | None = None,
        num: Incomplete | None = None,
    ): ...
    def zrangebylex(
        self, name: KeyT, min: _Value, max: _Value, start: int | None = None, num: int | None = None
    ) -> list[_StrType]: ...
    def zrevrangebylex(
        self, name: KeyT, max: _Value, min: _Value, start: int | None = None, num: int | None = None
    ) -> list[_StrType]: ...
    @overload
    def zrangebyscore(
        self,
        name: KeyT,
        min: _Value,
        max: _Value,
        start: int | None = None,
        num: int | None = None,
        *,
        withscores: Literal[True],
        score_cast_func: Callable[[_StrType], _ScoreCastFuncReturn],
    ) -> list[tuple[_StrType, _ScoreCastFuncReturn]]: ...
    @overload
    def zrangebyscore(
        self, name: KeyT, min: _Value, max: _Value, start: int | None = None, num: int | None = None, *, withscores: Literal[True]
    ) -> list[tuple[_StrType, float]]: ...
    @overload
    def zrangebyscore(
        self,
        name: KeyT,
        min: _Value,
        max: _Value,
        start: int | None = None,
        num: int | None = None,
        withscores: bool = False,
        score_cast_func: Callable[[_StrType], Any] = ...,
    ) -> list[_StrType]: ...
    @overload
    def zrevrangebyscore(
        self,
        name: KeyT,
        max: _Value,
        min: _Value,
        start: int | None = None,
        num: int | None = None,
        *,
        withscores: Literal[True],
        score_cast_func: Callable[[_StrType], _ScoreCastFuncReturn],
    ) -> list[tuple[_StrType, _ScoreCastFuncReturn]]: ...
    @overload
    def zrevrangebyscore(
        self, name: KeyT, max: _Value, min: _Value, start: int | None = None, num: int | None = None, *, withscores: Literal[True]
    ) -> list[tuple[_StrType, float]]: ...
    @overload
    def zrevrangebyscore(
        self,
        name: KeyT,
        max: _Value,
        min: _Value,
        start: int | None = None,
        num: int | None = None,
        withscores: bool = False,
        score_cast_func: Callable[[_StrType], Any] = ...,
    ) -> list[_StrType]: ...
    def zrank(self, name: KeyT, value: _Value, withscore: bool = False) -> int | None: ...
    def zrem(self, name: KeyT, *values: _Value) -> int: ...
    def zremrangebylex(self, name: KeyT, min: _Value, max: _Value) -> int: ...
    def zremrangebyrank(self, name: KeyT, min: int, max: int) -> int: ...
    def zremrangebyscore(self, name: KeyT, min: _Value, max: _Value) -> int: ...
    def zrevrank(self, name: KeyT, value: _Value, withscore: bool = False) -> int | None: ...
    def zscore(self, name: KeyT, value: _Value) -> float | None: ...
    def zunion(self, keys, aggregate: Incomplete | None = None, withscores: bool = False): ...
    def zunionstore(self, dest: KeyT, keys: Iterable[KeyT], aggregate: Literal["SUM", "MIN", "MAX"] | None = None) -> int: ...
    def zmscore(self, key, members): ...

AsyncSortedSetCommands = SortedSetCommands

class HyperlogCommands:
    def pfadd(self, name: KeyT, *values: _Value) -> int: ...
    def pfcount(self, name: KeyT) -> int: ...
    def pfmerge(self, dest: KeyT, *sources: KeyT) -> bool: ...

AsyncHyperlogCommands = HyperlogCommands

class HashCommands(Generic[_StrType]):
    def hdel(self, name: KeyT, *keys: KeyT) -> int: ...
    def hexists(self, name: KeyT, key: KeyT) -> bool: ...
    def hget(self, name: KeyT, key: KeyT) -> _StrType | None: ...
    def hgetall(self, name: KeyT) -> dict[_StrType, _StrType]: ...
    def hincrby(self, name: KeyT, key: KeyT, amount: int = 1) -> int: ...
    def hincrbyfloat(self, name: KeyT, key: KeyT, amount: float = 1.0) -> float: ...
    def hkeys(self, name: KeyT) -> list[_StrType]: ...
    def hlen(self, name: KeyT) -> int: ...
    @overload
    def hset(
        self, name: KeyT, key: KeyT, value: _Value, mapping: Mapping[KeyT, _Value] | None = None, items: Incomplete | None = None
    ) -> int: ...
    @overload
    def hset(
        self, name: KeyT, key: None, value: None, mapping: Mapping[KeyT, _Value], items: Incomplete | None = None
    ) -> int: ...
    @overload
    def hset(self, name: KeyT, *, mapping: Mapping[KeyT, _Value], items: Incomplete | None = None) -> int: ...
    def hsetnx(self, name: KeyT, key: KeyT, value: _Value) -> int: ...
    def hmset(self, name: KeyT, mapping: Mapping[KeyT, _Value]) -> bool: ...
    def hmget(self, name: KeyT, keys: KeyT | Iterable[KeyT], *args: KeyT) -> list[_StrType | None]: ...
    def hvals(self, name: KeyT) -> list[_StrType]: ...
    def hstrlen(self, name, key): ...

AsyncHashCommands = HashCommands

class AsyncScript:
    def __init__(self, registered_client: AsyncRedis[Any], script: ScriptTextT) -> None: ...
    async def __call__(
        self, keys: Sequence[KeyT] | None = None, args: Iterable[EncodableT] | None = None, client: AsyncRedis[Any] | None = None
    ): ...

class PubSubCommands:
    def publish(self, channel: KeyT, message: KeyT, **kwargs: _CommandOptions) -> int: ...
    def pubsub_channels(self, pattern: KeyT = "*", **kwargs: _CommandOptions) -> list[str]: ...
    def pubsub_numpat(self, **kwargs: _CommandOptions) -> int: ...
    def pubsub_numsub(self, *args: KeyT, **kwargs: _CommandOptions) -> list[tuple[str, int]]: ...

class AsyncPubSubCommands:
    async def publish(self, channel: KeyT, message: KeyT, **kwargs: _CommandOptions) -> int: ...
    async def pubsub_channels(self, pattern: KeyT = "*", **kwargs: _CommandOptions) -> list[str]: ...
    async def pubsub_numpat(self, **kwargs: _CommandOptions) -> int: ...
    async def pubsub_numsub(self, *args: KeyT, **kwargs: _CommandOptions) -> list[tuple[str, int]]: ...

class ScriptCommands(Generic[_StrType]):
    def eval(self, script, numkeys, *keys_and_args): ...
    def evalsha(self, sha, numkeys, *keys_and_args): ...
    def script_exists(self, *args): ...
    def script_debug(self, *args): ...
    def script_flush(self, sync_type: Incomplete | None = None): ...
    def script_kill(self): ...
    def script_load(self, script): ...
    def register_script(self, script: str | _StrType) -> Script: ...

class AsyncScriptCommands(Generic[_StrType]):
    async def eval(self, script, numkeys, *keys_and_args): ...
    async def evalsha(self, sha, numkeys, *keys_and_args): ...
    async def script_exists(self, *args): ...
    async def script_debug(self, *args): ...
    async def script_flush(self, sync_type: Incomplete | None = None): ...
    async def script_kill(self): ...
    async def script_load(self, script): ...
    def register_script(self, script: ScriptTextT) -> AsyncScript: ...  # type: ignore[override]

class GeoCommands:
    def geoadd(self, name, values, nx: bool = False, xx: bool = False, ch: bool = False): ...
    def geodist(self, name, place1, place2, unit: Incomplete | None = None): ...
    def geohash(self, name, *values): ...
    def geopos(self, name, *values): ...
    def georadius(
        self,
        name,
        longitude,
        latitude,
        radius,
        unit: Incomplete | None = None,
        withdist: bool = False,
        withcoord: bool = False,
        withhash: bool = False,
        count: Incomplete | None = None,
        sort: Incomplete | None = None,
        store: Incomplete | None = None,
        store_dist: Incomplete | None = None,
        any: bool = False,
    ): ...
    def georadiusbymember(
        self,
        name,
        member,
        radius,
        unit: Incomplete | None = None,
        withdist: bool = False,
        withcoord: bool = False,
        withhash: bool = False,
        count: Incomplete | None = None,
        sort: Incomplete | None = None,
        store: Incomplete | None = None,
        store_dist: Incomplete | None = None,
        any: bool = False,
    ): ...
    def geosearch(
        self,
        name,
        member: Incomplete | None = None,
        longitude: Incomplete | None = None,
        latitude: Incomplete | None = None,
        unit: str = "m",
        radius: Incomplete | None = None,
        width: Incomplete | None = None,
        height: Incomplete | None = None,
        sort: Incomplete | None = None,
        count: Incomplete | None = None,
        any: bool = False,
        withcoord: bool = False,
        withdist: bool = False,
        withhash: bool = False,
    ): ...
    def geosearchstore(
        self,
        dest,
        name,
        member: Incomplete | None = None,
        longitude: Incomplete | None = None,
        latitude: Incomplete | None = None,
        unit: str = "m",
        radius: Incomplete | None = None,
        width: Incomplete | None = None,
        height: Incomplete | None = None,
        sort: Incomplete | None = None,
        count: Incomplete | None = None,
        any: bool = False,
        storedist: bool = False,
    ): ...

class AsyncGeoCommands:
    async def geoadd(self, name, values, nx: bool = False, xx: bool = False, ch: bool = False): ...
    async def geodist(self, name, place1, place2, unit: Incomplete | None = None): ...
    async def geohash(self, name, *values): ...
    async def geopos(self, name, *values): ...
    async def georadius(
        self,
        name,
        longitude,
        latitude,
        radius,
        unit: Incomplete | None = None,
        withdist: bool = False,
        withcoord: bool = False,
        withhash: bool = False,
        count: Incomplete | None = None,
        sort: Incomplete | None = None,
        store: Incomplete | None = None,
        store_dist: Incomplete | None = None,
        any: bool = False,
    ): ...
    async def georadiusbymember(
        self,
        name,
        member,
        radius,
        unit: Incomplete | None = None,
        withdist: bool = False,
        withcoord: bool = False,
        withhash: bool = False,
        count: Incomplete | None = None,
        sort: Incomplete | None = None,
        store: Incomplete | None = None,
        store_dist: Incomplete | None = None,
        any: bool = False,
    ): ...
    async def geosearch(
        self,
        name,
        member: Incomplete | None = None,
        longitude: Incomplete | None = None,
        latitude: Incomplete | None = None,
        unit: str = "m",
        radius: Incomplete | None = None,
        width: Incomplete | None = None,
        height: Incomplete | None = None,
        sort: Incomplete | None = None,
        count: Incomplete | None = None,
        any: bool = False,
        withcoord: bool = False,
        withdist: bool = False,
        withhash: bool = False,
    ): ...
    async def geosearchstore(
        self,
        dest,
        name,
        member: Incomplete | None = None,
        longitude: Incomplete | None = None,
        latitude: Incomplete | None = None,
        unit: str = "m",
        radius: Incomplete | None = None,
        width: Incomplete | None = None,
        height: Incomplete | None = None,
        sort: Incomplete | None = None,
        count: Incomplete | None = None,
        any: bool = False,
        storedist: bool = False,
    ): ...

class ModuleCommands:
    def module_load(self, path, *args): ...
    def module_unload(self, name): ...
    def module_list(self): ...
    def command_info(self): ...
    def command_count(self): ...
    def command_getkeys(self, *args): ...
    def command(self): ...

class Script:
    registered_client: Incomplete
    script: Incomplete
    sha: Incomplete
    def __init__(self, registered_client, script) -> None: ...
    def __call__(self, keys=..., args=..., client: Incomplete | None = ...): ...
    def get_encoder(self): ...

class AsyncModuleCommands(ModuleCommands):
    async def command_info(self) -> None: ...

class ClusterCommands(CommandsProtocol):
    def cluster(self, cluster_arg: str, *args, **kwargs: _CommandOptions): ...
    def readwrite(self, **kwargs: _CommandOptions) -> bool: ...
    def readonly(self, **kwargs: _CommandOptions) -> bool: ...

AsyncClusterCommands = ClusterCommands

class FunctionCommands:
    def function_load(self, code: str, replace: bool | None = False) -> Awaitable[str] | str: ...
    def function_delete(self, library: str) -> Awaitable[str] | str: ...
    def function_flush(self, mode: str = "SYNC") -> Awaitable[str] | str: ...
    def function_list(self, library: str | None = "*", withcode: bool | None = False) -> Awaitable[list[Any]] | list[Any]: ...
    def fcall(self, function, numkeys: int, *keys_and_args: list[Any] | None) -> Awaitable[str] | str: ...
    def fcall_ro(self, function, numkeys: int, *keys_and_args: list[Any] | None) -> Awaitable[str] | str: ...
    def function_dump(self) -> Awaitable[str] | str: ...
    def function_restore(self, payload: str, policy: str | None = "APPEND") -> Awaitable[str] | str: ...
    def function_kill(self) -> Awaitable[str] | str: ...
    def function_stats(self) -> Awaitable[list[Any]] | list[Any]: ...

AsyncFunctionCommands = FunctionCommands

class GearsCommands:
    def tfunction_load(self, lib_code: str, replace: bool = ..., config: str | None = ...) -> ResponseT: ...
    def tfunction_delete(self, lib_name: str) -> ResponseT: ...
    def tfunction_list(self, with_code: bool = ..., verbose: int = ..., lib_name: str | None = ...) -> ResponseT: ...
    def tfcall(self, lib_name: str, func_name: str, keys: KeysT = ..., *args: list[Incomplete]) -> ResponseT: ...
    def tfcall_async(self, lib_name: str, func_name: str, keys: KeysT = ..., *args: list[Incomplete]) -> ResponseT: ...

AsyncGearsCommands = GearsCommands

class DataAccessCommands(
    BasicKeyCommands[_StrType],
    HyperlogCommands,
    HashCommands[_StrType],
    GeoCommands,
    ListCommands[_StrType],
    ScanCommands[_StrType],
    SetCommands[_StrType],
    StreamCommands,
    SortedSetCommands[_StrType],
    Generic[_StrType],
): ...
class AsyncDataAccessCommands(
    AsyncBasicKeyCommands[_StrType],
    AsyncHyperlogCommands,
    AsyncHashCommands[_StrType],
    AsyncGeoCommands,
    AsyncListCommands[_StrType],
    AsyncScanCommands[_StrType],
    AsyncSetCommands[_StrType],
    AsyncStreamCommands,
    AsyncSortedSetCommands[_StrType],
    Generic[_StrType],
): ...
class CoreCommands(
    ACLCommands[_StrType],
    ClusterCommands,
    DataAccessCommands[_StrType],
    ManagementCommands,
    ModuleCommands,
    PubSubCommands,
    ScriptCommands[_StrType],
    Generic[_StrType],
): ...
class AsyncCoreCommands(
    AsyncACLCommands[_StrType],
    AsyncClusterCommands,
    AsyncDataAccessCommands[_StrType],
    AsyncManagementCommands,
    AsyncModuleCommands,
    AsyncPubSubCommands,
    AsyncScriptCommands[_StrType],
    AsyncFunctionCommands,
    Generic[_StrType],
): ...
