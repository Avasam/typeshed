from _typeshed import Incomplete
from collections.abc import AsyncIterator, Iterator, Mapping
from typing import Generic

from redis.asyncio.cluster import TargetNodesT

from ..typing import AnyKeyT, ClusterCommandsProtocol, EncodableT, KeysT, KeyT, PatternT
from .core import (
    ACLCommands,
    AsyncACLCommands,
    AsyncDataAccessCommands,
    AsyncFunctionCommands,
    AsyncGearsCommands,
    AsyncManagementCommands,
    AsyncModuleCommands,
    AsyncScriptCommands,
    DataAccessCommands,
    FunctionCommands,
    GearsCommands,
    ManagementCommands,
    ModuleCommands,
    PubSubCommands,
    ResponseT,
    ScriptCommands,
    _StrType,
)
from .redismodules import RedisModuleCommands

READ_COMMANDS: Incomplete

class ClusterMultiKeyCommands(ClusterCommandsProtocol):
    def mget_nonatomic(self, keys, *args): ...
    def mset_nonatomic(self, mapping): ...
    def exists(self, *keys): ...
    def delete(self, *keys): ...
    def touch(self, *keys): ...
    def unlink(self, *keys): ...

class AsyncClusterMultiKeyCommands(ClusterMultiKeyCommands):
    async def mget_nonatomic(self, keys: KeysT, *args: KeyT) -> list[Incomplete | None]: ...
    async def mset_nonatomic(self, mapping: Mapping[AnyKeyT, EncodableT]) -> list[bool]: ...

class ClusterManagementCommands(ManagementCommands):
    def slaveof(self, *args, **kwargs) -> None: ...
    def replicaof(self, *args, **kwargs) -> None: ...
    def swapdb(self, *args, **kwargs) -> None: ...
    def cluster_myid(self, target_node: TargetNodesT) -> ResponseT: ...
    def cluster_addslots(self, target_node: TargetNodesT, *slots: EncodableT) -> ResponseT: ...
    def cluster_addslotsrange(self, target_node: TargetNodesT, *slots: EncodableT) -> ResponseT: ...
    def cluster_countkeysinslot(self, slot_id: int) -> ResponseT: ...
    def cluster_count_failure_report(self, node_id: str) -> ResponseT: ...
    def cluster_delslots(self, *slots: EncodableT) -> list[bool]: ...
    def cluster_delslotsrange(self, *slots: EncodableT) -> ResponseT: ...
    def cluster_failover(self, target_node: TargetNodesT, option: str | None = ...) -> ResponseT: ...
    def cluster_info(self, target_nodes: TargetNodesT | None = ...) -> ResponseT: ...
    def cluster_keyslot(self, key: str) -> ResponseT: ...
    def cluster_meet(self, host: str, port: int, target_nodes: TargetNodesT | None = ...) -> ResponseT: ...
    def cluster_nodes(self) -> ResponseT: ...
    def cluster_replicate(self, target_nodes: TargetNodesT, node_id: str) -> ResponseT: ...
    def cluster_reset(self, soft: bool = ..., target_nodes: TargetNodesT | None = ...) -> ResponseT: ...
    def cluster_save_config(self, target_nodes: TargetNodesT | None = ...) -> ResponseT: ...
    def cluster_get_keys_in_slot(self, slot: int, num_keys: int) -> ResponseT: ...
    def cluster_set_config_epoch(self, epoch: int, target_nodes: TargetNodesT | None = ...) -> ResponseT: ...
    def cluster_setslot(self, target_node: TargetNodesT, node_id: str, slot_id: int, state: str) -> ResponseT: ...
    def cluster_setslot_stable(self, slot_id: int) -> ResponseT: ...
    def cluster_replicas(self, node_id: str, target_nodes: TargetNodesT | None = ...) -> ResponseT: ...
    def cluster_slots(self, target_nodes: TargetNodesT | None = ...) -> ResponseT: ...
    def cluster_shards(self, target_nodes: Incomplete | None = ...): ...
    def cluster_myshardid(self, target_nodes: Incomplete | None = ...): ...
    def cluster_links(self, target_node: TargetNodesT) -> ResponseT: ...
    def cluster_flushslots(self, target_nodes: TargetNodesT | None = ...) -> None: ...
    def cluster_bumpepoch(self, target_nodes: TargetNodesT | None = ...) -> None: ...
    read_from_replicas: bool
    def readonly(self, target_nodes: TargetNodesT | None = ...) -> ResponseT: ...
    def readwrite(self, target_nodes: TargetNodesT | None = ...) -> ResponseT: ...
    def gears_refresh_cluster(self, **kwargs) -> ResponseT: ...

class AsyncClusterManagementCommands(ClusterManagementCommands, AsyncManagementCommands):
    async def cluster_delslots(self, *slots: EncodableT) -> list[bool]: ...  # type: ignore[override]  # Incompatible return type

class ClusterDataAccessCommands(DataAccessCommands[_StrType], Generic[_StrType]):
    def stralgo(
        self,
        algo,
        value1,
        value2,
        specific_argument: str = "strings",
        len: bool = False,
        idx: bool = False,
        minmatchlen: Incomplete | None = None,
        withmatchlen: bool = False,
        **kwargs,
    ): ...
    def scan_iter(
        self, match: PatternT | None = ..., count: int | None = ..., _type: str | None = ..., **kwargs
    ) -> Iterator[Incomplete]: ...

class AsyncClusterDataAccessCommands(ClusterDataAccessCommands[_StrType], AsyncDataAccessCommands[_StrType]):
    async def scan_iter(  # type: ignore[override]  # Incompatible return type
        self, match: PatternT | None = ..., count: int | None = ..., _type: str | None = ..., **kwargs
    ) -> AsyncIterator[Incomplete]: ...

class RedisClusterCommands(
    ClusterMultiKeyCommands,
    ClusterManagementCommands,
    ACLCommands[_StrType],
    PubSubCommands,
    ClusterDataAccessCommands[_StrType],
    ScriptCommands[_StrType],
    FunctionCommands,
    GearsCommands,
    ModuleCommands,
    RedisModuleCommands,
): ...
class AsyncRedisClusterCommands(  # type: ignore[misc]  # Incompatible base class
    AsyncClusterMultiKeyCommands,
    AsyncClusterManagementCommands,
    AsyncACLCommands[_StrType],
    AsyncClusterDataAccessCommands[_StrType],
    AsyncScriptCommands[_StrType],
    AsyncFunctionCommands,
    AsyncGearsCommands,
    AsyncModuleCommands,
): ...
