from _typeshed import Incomplete
from typing import ClassVar

default_pool: DescriptorPool

class Arena: ...

class Descriptor:
    containing_type: Incomplete
    enum_types: Incomplete
    enum_types_by_name: Incomplete
    enum_values_by_name: Incomplete
    extension_ranges: Incomplete
    extensions: Incomplete
    extensions_by_name: Incomplete
    fields: Incomplete
    fields_by_camelcase_name: Incomplete
    fields_by_name: Incomplete
    fields_by_number: Incomplete
    file: Incomplete
    full_name: Incomplete
    has_options: Incomplete
    is_extendable: Incomplete
    name: Incomplete
    nested_types: Incomplete
    nested_types_by_name: Incomplete
    oneofs: Incomplete
    oneofs_by_name: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...  # incomplete
    def CopyToProto(self, *args, **kwargs): ...  # incomplete
    def EnumValueName(self, *args, **kwargs): ...  # incomplete
    def GetOptions(self, *args, **kwargs): ...  # incomplete

class DescriptorPool:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...  # incomplete
    def Add(self, *args, **kwargs): ...  # incomplete
    def AddSerializedFile(self, *args, **kwargs): ...  # incomplete
    def FindAllExtensions(self, *args, **kwargs): ...  # incomplete
    def FindEnumTypeByName(self, *args, **kwargs): ...  # incomplete
    def FindExtensionByName(self, *args, **kwargs): ...  # incomplete
    def FindExtensionByNumber(self, *args, **kwargs): ...  # incomplete
    def FindFieldByName(self, *args, **kwargs): ...  # incomplete
    def FindFileByName(self, *args, **kwargs): ...  # incomplete
    def FindFileContainingSymbol(self, *args, **kwargs): ...  # incomplete
    def FindMessageTypeByName(self, *args, **kwargs): ...  # incomplete
    def FindMethodByName(self, *args, **kwargs): ...  # incomplete
    def FindOneofByName(self, *args, **kwargs): ...  # incomplete
    def FindServiceByName(self, *args, **kwargs): ...  # incomplete
    def SetFeatureSetDefaults(self, *args, **kwargs): ...  # incomplete

class EnumDescriptor:
    containing_type: Incomplete
    file: Incomplete
    full_name: Incomplete
    has_options: Incomplete
    is_closed: Incomplete
    name: Incomplete
    values: Incomplete
    values_by_name: Incomplete
    values_by_number: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...  # incomplete
    def CopyToProto(self, *args, **kwargs): ...  # incomplete
    def GetOptions(self, *args, **kwargs): ...  # incomplete

class EnumValueDescriptor:
    has_options: Incomplete
    index: Incomplete
    name: Incomplete
    number: Incomplete
    type: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...  # incomplete
    def GetOptions(self, *args, **kwargs): ...  # incomplete

class ExtensionDict:
    def __contains__(self, other) -> bool: ...
    def __delitem__(self, other) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getitem__(self, index): ...
    def __gt__(self, other: object) -> bool: ...
    def __iter__(self): ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, index, object) -> None: ...

class ExtensionIterator:
    def __iter__(self): ...
    def __next__(self): ...

class FieldDescriptor:
    CPPTYPE_BOOL: ClassVar[int] = ...
    CPPTYPE_BYTES: ClassVar[int] = ...
    CPPTYPE_DOUBLE: ClassVar[int] = ...
    CPPTYPE_ENUM: ClassVar[int] = ...
    CPPTYPE_FLOAT: ClassVar[int] = ...
    CPPTYPE_INT32: ClassVar[int] = ...
    CPPTYPE_INT64: ClassVar[int] = ...
    CPPTYPE_MESSAGE: ClassVar[int] = ...
    CPPTYPE_STRING: ClassVar[int] = ...
    CPPTYPE_UINT32: ClassVar[int] = ...
    CPPTYPE_UINT64: ClassVar[int] = ...
    LABEL_OPTIONAL: ClassVar[int] = ...
    LABEL_REPEATED: ClassVar[int] = ...
    LABEL_REQUIRED: ClassVar[int] = ...
    TYPE_BOOL: ClassVar[int] = ...
    TYPE_BYTES: ClassVar[int] = ...
    TYPE_DOUBLE: ClassVar[int] = ...
    TYPE_ENUM: ClassVar[int] = ...
    TYPE_FIXED32: ClassVar[int] = ...
    TYPE_FIXED64: ClassVar[int] = ...
    TYPE_FLOAT: ClassVar[int] = ...
    TYPE_GROUP: ClassVar[int] = ...
    TYPE_INT32: ClassVar[int] = ...
    TYPE_INT64: ClassVar[int] = ...
    TYPE_MESSAGE: ClassVar[int] = ...
    TYPE_SFIXED32: ClassVar[int] = ...
    TYPE_SFIXED64: ClassVar[int] = ...
    TYPE_SINT32: ClassVar[int] = ...
    TYPE_SINT64: ClassVar[int] = ...
    TYPE_STRING: ClassVar[int] = ...
    TYPE_UINT32: ClassVar[int] = ...
    TYPE_UINT64: ClassVar[int] = ...
    camelcase_name: Incomplete
    containing_oneof: Incomplete
    containing_type: Incomplete
    cpp_type: Incomplete
    default_value: Incomplete
    enum_type: Incomplete
    extension_scope: Incomplete
    file: Incomplete
    full_name: Incomplete
    has_default_value: Incomplete
    has_options: Incomplete
    has_presence: Incomplete
    index: Incomplete
    is_extension: Incomplete
    is_packed: Incomplete
    json_name: Incomplete
    label: Incomplete
    message_type: Incomplete
    name: Incomplete
    number: Incomplete
    type: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...  # incomplete
    def GetOptions(self, *args, **kwargs): ...  # incomplete

class FileDescriptor:
    dependencies: Incomplete
    enum_types_by_name: Incomplete
    extensions_by_name: Incomplete
    has_options: Incomplete
    message_types_by_name: Incomplete
    name: Incomplete
    package: Incomplete
    pool: Incomplete
    public_dependencies: Incomplete
    serialized_pb: Incomplete
    services_by_name: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...  # incomplete
    def CopyToProto(self, *args, **kwargs): ...  # incomplete
    def GetOptions(self, *args, **kwargs): ...  # incomplete

class MapIterator:
    def __iter__(self): ...
    def __next__(self): ...

class Message:
    Extensions: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...  # incomplete
    def ByteSize(self, *args, **kwargs): ...  # incomplete
    def Clear(self, *args, **kwargs): ...  # incomplete
    def ClearExtension(self, *args, **kwargs): ...  # incomplete
    def ClearField(self, *args, **kwargs): ...  # incomplete
    def CopyFrom(self, *args, **kwargs): ...  # incomplete
    def DiscardUnknownFields(self, *args, **kwargs): ...  # incomplete
    def FindInitializationErrors(self, *args, **kwargs): ...  # incomplete
    @classmethod
    def FromString(cls, *args, **kwargs): ...  # incomplete
    def HasExtension(self, *args, **kwargs): ...  # incomplete
    def HasField(self, *args, **kwargs): ...  # incomplete
    def IsInitialized(self, *args, **kwargs): ...  # incomplete
    def ListFields(self, *args, **kwargs): ...  # incomplete
    def MergeFrom(self, *args, **kwargs): ...  # incomplete
    def MergeFromString(self, *args, **kwargs): ...  # incomplete
    def ParseFromString(self, *args, **kwargs): ...  # incomplete
    def SerializePartialToString(self, *args, **kwargs): ...  # incomplete
    def SerializeToString(self, *args, **kwargs): ...  # incomplete
    def SetInParent(self, *args, **kwargs): ...  # incomplete
    def UnknownFields(self, *args, **kwargs): ...  # incomplete
    def WhichOneof(self, *args, **kwargs): ...  # incomplete
    def __contains__(self, other) -> bool: ...
    def __deepcopy__(self): ...
    def __delattr__(self, name): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setattr__(self, name, value): ...

class MessageMeta(type):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...  # incomplete

class MethodDescriptor:
    client_streaming: Incomplete
    containing_service: Incomplete
    full_name: Incomplete
    index: Incomplete
    input_type: Incomplete
    name: Incomplete
    output_type: Incomplete
    server_streaming: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...  # incomplete
    def CopyToProto(self, *args, **kwargs): ...  # incomplete
    def GetOptions(self, *args, **kwargs): ...  # incomplete

class OneofDescriptor:
    containing_type: Incomplete
    fields: Incomplete
    full_name: Incomplete
    has_options: Incomplete
    index: Incomplete
    name: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...  # incomplete
    def GetOptions(self, *args, **kwargs): ...  # incomplete

class RepeatedCompositeContainer:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...  # incomplete
    def MergeFrom(self, *args, **kwargs): ...  # incomplete
    def add(self, *args, **kwargs): ...  # incomplete
    def append(self, *args, **kwargs): ...  # incomplete
    def extend(self, *args, **kwargs): ...  # incomplete
    def insert(self, *args, **kwargs): ...  # incomplete
    def pop(self, *args, **kwargs): ...  # incomplete
    def remove(self, *args, **kwargs): ...  # incomplete
    def reverse(self, *args, **kwargs): ...  # incomplete
    def sort(self, *args, **kwargs): ...  # incomplete
    def __deepcopy__(self): ...
    def __delitem__(self, other) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getitem__(self, index): ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, index, object) -> None: ...

class RepeatedScalarContainer:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...  # incomplete
    def MergeFrom(self, *args, **kwargs): ...  # incomplete
    def append(self, *args, **kwargs): ...  # incomplete
    def extend(self, *args, **kwargs): ...  # incomplete
    def insert(self, *args, **kwargs): ...  # incomplete
    def pop(self, *args, **kwargs): ...  # incomplete
    def remove(self, *args, **kwargs): ...  # incomplete
    def reverse(self, *args, **kwargs): ...  # incomplete
    def sort(self, *args, **kwargs): ...  # incomplete
    def __deepcopy__(self): ...
    def __delitem__(self, other) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getitem__(self, index): ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __reduce__(self): ...
    def __setitem__(self, index, object) -> None: ...

class ServiceDescriptor:
    file: Incomplete
    full_name: Incomplete
    index: Incomplete
    methods: Incomplete
    methods_by_name: Incomplete
    name: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...  # incomplete
    def CopyToProto(self, *args, **kwargs): ...  # incomplete
    def FindMethodByName(self, *args, **kwargs): ...  # incomplete
    def GetOptions(self, *args, **kwargs): ...  # incomplete

class UnknownFieldSet:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...  # incomplete
    def __getitem__(self, index): ...
    def __hash__(self) -> int: ...
    def __len__(self) -> int: ...

class _ByNameIterator:
    def __iter__(self): ...
    def __next__(self): ...

class _ByNameMap:
    def get(self, *args, **kwargs): ...  # incomplete
    def items(self, *args, **kwargs): ...  # incomplete
    def keys(self, *args, **kwargs): ...  # incomplete
    def values(self, *args, **kwargs): ...  # incomplete
    def __contains__(self, other) -> bool: ...
    def __delitem__(self, other) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getitem__(self, index): ...
    def __gt__(self, other: object) -> bool: ...
    def __iter__(self): ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, index, object) -> None: ...

class _ByNumberIterator:
    def __iter__(self): ...
    def __next__(self): ...

class _ByNumberMap:
    def get(self, *args, **kwargs): ...  # incomplete
    def items(self, *args, **kwargs): ...  # incomplete
    def keys(self, *args, **kwargs): ...  # incomplete
    def values(self, *args, **kwargs): ...  # incomplete
    def __contains__(self, other) -> bool: ...
    def __delitem__(self, other) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getitem__(self, index): ...
    def __gt__(self, other: object) -> bool: ...
    def __iter__(self): ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, index, object) -> None: ...

class _GenericSequence:
    def append(self, *args, **kwargs): ...  # incomplete
    def count(self, *args, **kwargs): ...  # incomplete
    def index(self, *args, **kwargs): ...  # incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getitem__(self, index): ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

def SetAllowOversizeProtos(*args, **kwargs): ...  # incomplete
