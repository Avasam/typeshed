from _typeshed import Incomplete
from abc import ABCMeta
from collections.abc import ItemsView, KeysView, Mapping, Sequence, ValuesView
from typing import Any, TypeVar

from ..cresultproxy import BaseRow as BaseRow
from ..engine.result import RMKeyView

_T = TypeVar("_T")

MD_INDEX: int

def rowproxy_reconstructor(cls: type[_T], state: dict[str, Incomplete]) -> _T: ...

KEY_INTEGER_ONLY: int
KEY_OBJECTS_ONLY: int
KEY_OBJECTS_BUT_WARN: int
KEY_OBJECTS_NO_WARN: int

class Row(  # type: ignore[misc]  # BaseRow.__getitem__ supports objects as index
    BaseRow[Incomplete], Sequence[Incomplete], metaclass=ABCMeta
):
    @property
    def count(self): ...
    @property
    def index(self): ...
    def __contains__(self, key) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def keys(self) -> RMKeyView: ...

class LegacyRow(Row, metaclass=ABCMeta):
    def __contains__(self, key) -> bool: ...
    def has_key(self, key) -> bool: ...
    def items(self): ...
    def iterkeys(self): ...
    def itervalues(self): ...
    def values(self): ...

BaseRowProxy = BaseRow
RowProxy = Row

class ROMappingView(KeysView[Any], ValuesView[Any], ItemsView[Any, Any]):
    def __init__(self, mapping, items) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self): ...
    def __contains__(self, item) -> bool: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...

class RowMapping(BaseRow[Incomplete], Mapping[Incomplete, Incomplete]):
    __getitem__: Any
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def __contains__(self, key) -> bool: ...
    def items(self): ...
    def keys(self): ...
    def values(self): ...
