from _typeshed import Incomplete
from abc import ABCMeta, abstractmethod
from typing import ClassVar, TypeVar
from typing_extensions import Literal, LiteralString

from .pytree import Base, Leaf, Node

_N = TypeVar("_N", bound=Base)

class BaseFix:
    PATTERN: ClassVar[LiteralString | None]
    pattern_tree: Incomplete | None
    options: Incomplete | None
    filename: Incomplete | None
    numbers: Incomplete
    used_names: Incomplete
    order: ClassVar[Literal["post", "pre"]]
    explicit: bool
    run_order: ClassVar[int]
    keep_line_order: ClassVar[bool]
    BM_compatible: ClassVar[bool]
    syms: Incomplete
    log: Incomplete
    def __init__(self, options, log) -> None: ...
    def compile_pattern(self) -> None: ...
    def set_filename(self, filename) -> None: ...
    def match(self, node: _N) -> Literal[False] | dict[str, _N]: ...
    @abstractmethod
    def transform(self, node: Base, results: dict[str, Base]) -> Node | Leaf | None: ...
    def new_name(self, template: str = "xxx_todo_changeme") -> str: ...
    first_log: bool
    def log_message(self, message) -> None: ...
    def cannot_convert(self, node: Base, reason: Incomplete | None = None) -> None: ...
    def warning(self, node: Base, reason) -> None: ...
    def start_tree(self, tree, filename) -> None: ...
    def finish_tree(self, tree, filename) -> None: ...

class ConditionalFix(BaseFix, metaclass=ABCMeta):
    skip_on: ClassVar[LiteralString | None]
    def start_tree(self, *args) -> None: ...
    def should_skip(self, node: Base) -> bool: ...
