from _typeshed import Incomplete
from collections.abc import Generator

HUGE: int

def type_repr(type_num): ...

class Base:
    type: Incomplete
    parent: Incomplete
    children: Incomplete
    was_changed: bool
    was_checked: bool
    def __new__(cls, *args, **kwds): ...
    def __eq__(self, other): ...
    __hash__: Incomplete
    def clone(self) -> None: ...
    def post_order(self) -> None: ...
    def pre_order(self) -> None: ...
    def replace(self, new) -> None: ...
    def get_lineno(self): ...
    def changed(self) -> None: ...
    def remove(self): ...
    @property
    def next_sibling(self): ...
    @property
    def prev_sibling(self): ...
    def leaves(self) -> None: ...
    def depth(self): ...
    def get_suffix(self): ...

class Node(Base):
    type: Incomplete
    children: Incomplete
    fixers_applied: Incomplete
    def __init__(self, type, children, context: Incomplete | None = ..., prefix: Incomplete | None = ..., fixers_applied: Incomplete | None = ...) -> None: ...
    def __unicode__(self): ...
    def clone(self): ...
    def post_order(self) -> Generator[Incomplete, None, None]: ...
    def pre_order(self) -> Generator[Incomplete, None, None]: ...
    @property
    def prefix(self): ...
    @prefix.setter
    def prefix(self, prefix) -> None: ...
    def set_child(self, i, child) -> None: ...
    def insert_child(self, i, child) -> None: ...
    def append_child(self, child) -> None: ...

class Leaf(Base):
    lineno: int
    column: int
    type: Incomplete
    value: Incomplete
    fixers_applied: Incomplete
    def __init__(self, type, value, context: Incomplete | None = ..., prefix: Incomplete | None = ..., fixers_applied=...) -> None: ...
    def __unicode__(self): ...
    def clone(self): ...
    def leaves(self) -> Generator[Incomplete, None, None]: ...
    def post_order(self) -> Generator[Incomplete, None, None]: ...
    def pre_order(self) -> Generator[Incomplete, None, None]: ...
    @property
    def prefix(self): ...
    @prefix.setter
    def prefix(self, prefix) -> None: ...

def convert(gr, raw_node): ...

class BasePattern:
    type: Incomplete
    content: Incomplete
    name: Incomplete
    def __new__(cls, *args, **kwds): ...
    def optimize(self): ...
    def match(self, node, results: Incomplete | None = ...): ...
    def match_seq(self, nodes, results: Incomplete | None = ...): ...
    def generate_matches(self, nodes) -> Generator[Incomplete, None, None]: ...

class LeafPattern(BasePattern):
    type: Incomplete
    content: Incomplete
    name: Incomplete
    def __init__(self, type: Incomplete | None = ..., content: Incomplete | None = ..., name: Incomplete | None = ...) -> None: ...
    def match(self, node, results: Incomplete | None = ...): ...

class NodePattern(BasePattern):
    wildcards: bool
    type: Incomplete
    content: Incomplete
    name: Incomplete
    def __init__(self, type: Incomplete | None = ..., content: Incomplete | None = ..., name: Incomplete | None = ...) -> None: ...

class WildcardPattern(BasePattern):
    content: Incomplete
    min: Incomplete
    max: Incomplete
    name: Incomplete
    def __init__(self, content: Incomplete | None = ..., min: int = ..., max=..., name: Incomplete | None = ...) -> None: ...
    def optimize(self): ...
    def match(self, node, results: Incomplete | None = ...): ...
    def match_seq(self, nodes, results: Incomplete | None = ...): ...
    def generate_matches(self, nodes) -> Generator[Incomplete, None, None]: ...

class NegatedPattern(BasePattern):
    content: Incomplete
    def __init__(self, content: Incomplete | None = ...) -> None: ...
    def match(self, node): ...
    def match_seq(self, nodes): ...
    def generate_matches(self, nodes) -> Generator[Incomplete, None, None]: ...

def generate_matches(patterns, nodes) -> Generator[Incomplete, None, None]: ...
